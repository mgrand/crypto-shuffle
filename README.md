# crypto-shuffle 0.7

This is a symmetric encryption algorithm for use in applications like
protecting the secrecy of blockchain contents where the encryption needs
to be very strong. The algorithm has these properties:

* It is necessary to decrypt the entire text at once, rather than
  decrypt in pieces, as with a block cypher.
* The key can as as long as the plaintext message or 
longer.
* All wrong plain texts the same length as the correct
plain text can be generated by wrong keys. This Ensures 
that too many plausible plaintext's that can be generated to
tell by brute force which is the correct one.

The encryption algorithm is very simple:
1. If the plaintext is longer then the key, fail.
2. If the plaintext is shorter than the key, pad it to
the length of the key with null bytes (0).
3. XOR the key with the padded plain text. The result
is the encrypted text.

The decryption algorithm is the same.

## Key Management

Each plaintext that is encrypted should be encrypted with a different
key. If it is known that two encrypted texts were encrypted with the
same key, then it becomes easier to guess the key. For this reason, the
crypto-shuffle library includes a `RandomKeyGenerator` class to generate
random keys.

The most secure way to share the key to decrypt a message is to keep it
somewhere different than the encrypted message. However this creates the
challenge of creating a mechanism to manage all of the random key and
keeping track of which key goes with which encrypted text. The
inconvenience of having to do this may be unacceptable.

### Sharing Keys on the Blockchain

If the encrypted message is stored on a blockchain, it may be considered
convenient to store the crypto-shuffle key on the same blockchain.  In
these cases, it is recommended that the key be encrypted with the public
keys of the parties that you want to share the plaintext with.

The crypto-shuffle package includes a convenient mechanism for creating
a single JSON object that contains versions of crypto-shuffle keys
encrypted by each of a set of public keys. This is the `MultiEncryption`
class.

To create a `MultiEncryption` object, you pass the constructor a plain
text crypto-shuffle key and a collection of one or more public keys. The
constructed object contains versions of the crypto-shuffle key encrypted
by each of the public keys.

To decrypt the contents of a `MultiEncryption` object, pass a public key
and its corresponding private key to the `MultiEncryption` objectâ€™s
`decrypt` method. If the `MultiEncryption` object contains an encrypted
crypto-shuffle key that was encrypted with the given public key, it uses
the corresponding private key to decrypt the crypto-shuffle key.

You can generate a JSON representation of a `MultiEncryption` object by
calling its `toJson` method. Provide JSON version of the
`MultiEncryption` object as a field value in the same transaction as
you have encrypted values. If someone wants to convert the JSON into a
`MultiEncryption` object, they can pass the JSON to the static method
`MultiEncryption.fromJson`.

### Sharing Keys Outside the Blockchain
Sharing keys through a means outside of the blockchain is the most secure
way to share keys.

__Note:__ This version of cryptoshuffle is not compatible 
with previous versions. 