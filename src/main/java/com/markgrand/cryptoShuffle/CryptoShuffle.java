package com.markgrand.cryptoShuffle;

import static com.markgrand.cryptoShuffle.Constants.*;
import org.jetbrains.annotations.NotNull;

/**
 * <p>This is a symmetric encryption algorithm for use in applications like
 * protecting the secrecy of blockchain contents where the encryption needs
 * to be very strong. The algorithm has these properties:</p>
 * <ul>
 * <li>It is necessary to decrypt the entire text at once, rather than decrypt in pieces, as with a block cypher.</li>
 * <li>The key can as as long as the plaintext message or longer.</li>
 * <li>All wrong plain texts the same length as the correct plain text can be generated by wrong keys. This ensures
 * that too many plausible plaintext's that can be generated to tell by brute force which is the correct one.</li>
 * </ul>
 * <p>
 * The encryption algorithm is very simple:
 * <nl>
 * <li>If the plaintext is longer then the key, fail.</li>
 * <li>If the plaintext is shorter than the key, pad it to the length of the key with null bytes (0).</li>
 * <li>XOR the key with the padded plain text. The result is the encrypted text.</li>
 * </nl>
 * <p>
 * The decryption algorithm is the same.
 *
 * @author Mark Grand
 */
@SuppressWarnings({"unused", "WeakerAccess"})
public class CryptoShuffle {
    /**
     * Encrypt the given plaintext using the given key.
     *
     * @param plaintext The plain text to be encrypted.
     * @param key       The encryption key.
     * @return The encrypted version of the plaintext.
     * @throws IllegalArgumentException if the key is shorter than the plaintext.
     */
    @NotNull
    public static byte[] encrypt(@NotNull final byte[] plaintext, @NotNull final byte[] key) {
        ensureKeyNotShorterThanPlaintext(plaintext, key);
        final byte[] encrypted = new byte[key.length + 1];
        encrypted[0] = VERSION;
        System.arraycopy(plaintext, 0, encrypted, 1, key.length);
        for (int i=0; i<key.length; i++) {
            encrypted[i+1] ^= key[i];
        }
        return encrypted;
    }

    private static void ensureKeyNotShorterThanPlaintext(@NotNull byte[] plaintext, @NotNull byte[] key) {
        if (key.length < plaintext.length) {
            String msg = "The key cannot be shorter than the plain text. the Key length is " + key.length
                    + "; the plain text length is " + plaintext.length;
            throw new IllegalArgumentException(msg);
        }
    }

    /**
     * Decrypt the given encrypted bytes with the given key.
     * @param encrypted
     * @param key
     * @return
     */
    @NotNull
    public static byte[] decrypt(@NotNull final byte[] encrypted, @NotNull final byte[] key) {
        switch (encrypted[0]) {
            case VERSION_THREE:
                return decryptV3(encrypted, key);
        }
        @NotNull String msg = "Encrypted bytes were encrypted with an unsupported version of cyrptoshuffle:";
        throw new IllegalArgumentException(msg + (int) encrypted[0]);
    }

    @NotNull
    private static byte[] decryptV3(@NotNull final byte[] encrypted, @NotNull final byte[] key) {
        if (encrypted.length != key.length + 1) {
            throw new IllegalArgumentException("Invalid key.");
        }
        byte[] decrypted = new byte[key.length];
        for (int i = 0; i < key.length; i++) {
            decrypted[i] = (byte)(encrypted[i+1] ^ key[i]);
        }
        return decrypted;
    }
}
